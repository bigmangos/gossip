{"pageProps":{"user":{"login":"qianxi0410","nick_name":"q1anx1","avatar_url":"https://avatars.githubusercontent.com/u/55543743?v=4","bio":"gopher at day, rustacean at night."},"posts":[{"id":5,"title":"Go的依赖更新检查工具","created_at":"2022-05-07T10:25:20Z","updated_at":"2022-07-19T05:14:19Z","content":"`go module`，这是一个 Go 官方经历了多年，终于打算 **放下身段** 汲取前人的经验所设计出来的一个产物，其历史可以参阅 Go官方的 [wiki](https://github.com/golang/go/wiki/Modules)。~~所以说，后来的 Gopher 们，那些口口声声， 一代不如一代的人，应该看着你们； 像我一样，我看着你们，满怀羡慕。~~\r\n\r\n由于 Go 的一些哲学：比如遵循 [语义化版本控制](https://semver.org/lang/zh-CN/)，并且相同路径所引入的包必须向后兼容。这就要求库作者在发布大版本变动时，需要更改自身库的引入路径。综上的一切，导致了 Go 的更新依赖工具在检查依赖时，并不能进行主要版本号的更新，但那又怎么样呢？ **我偏要勉强！**\r\n\r\n于是乎，追求最新版本的我，打算写一个能够 [更新 go.mod 依赖主版本的工具](https://github.com/qianxi0410/gcu)。\r\n\r\n在写它之前，需要读过 [这篇文章](https://go.dev/ref/mod)，里面讲述了 Go 依赖的引入规则和一些 Go 模块命令的用法，并且还介绍了 Go 自己的一个 [依赖检查数据库网站](https://proxy.golang.org/)，这个网站是后续获取新版本依赖的关键。\r\n\r\n看完之后，你应该有了一个大致的思路：\r\n\r\n首先，需要能够解析出 `go.mod` 文件中所出现的依赖，由于 Go 的最小版本依赖原则，只需要将其中的直接依赖提取出来即可。\r\n\r\n其次，将提取出来的依赖到上文提到的数据库中进行查询，得到现在最新的版本，写入 `go.mod` 文件。\r\n\r\n写入完之后，判断新依赖的主版本是否 ` >= 1`，如果不是，则升级过程到此结束。否则，需要判断其是否带有 `+incompatible` 标签，如果带有该标签，则不用进行后续的文件重写步骤，如果没有，需要遍历当前工作目录，重写主版本更新之后的模块的引入路径。\r\n\r\n以上，你就完成了一个能够升级主要版本依赖的工具的核心功能。\r\n\r\n当然，这也是 `gcu` 的雏形，但它作为一个 cli 工具，能做的远不止如此：\r\n\r\n- 它有丰富的TUI\r\n- 它能够提供可选的依赖更新\r\n- 如果你比较保守，它也能够不进行主要版本的更新，只进行次要版本和补丁版本的更新\r\n- 它进行了多线程加速 ~~所以它很快~~\r\n- 它能够更新 Go 语言写的二进制文件的版本\r\n\r\n目前，该工具还是在制中，因为 ~~一米八的~~ 我仍然在让它变得更快！","author":"qianxi0410"},{"id":4,"title":"生活在linux上","created_at":"2022-05-03T06:27:37Z","updated_at":"2022-07-19T05:13:57Z","content":"现代操作系统以华为的 \"鸿蒙HarmonyOS 系统是面向万物互联的全场景分布式操作系统\" 为嚆矢。滥觞于玄学与数学的期望正失去它们的借鉴意义。但面对看似无垠的未来天空，我想循linus \"A computer is like air conditioning – it becomes useless when you open  Windows.\" 好过过早地振翮。\r\n\r\n我们怀揣热忱的灵魂天然被赋予对超越性的追求，不屑于古旧坐标的约束，钟情于在别处的芬芳。但当这种期望流于对Windows主义不假思索的批判，乃至走向原教旨与开源主义时，便值得警惕了。与秩序的落差、错位向来不能为越矩的行为张本。而纵然我们已有翔实的蓝图，仍不能自持已在浪潮之巅立下了自己的沉锚。\r\n\r\n\"wsl is a better way to use linux.\" M$之言可谓切中了肯綮。人的好奇心是不可祓除的，而我们欲上青云也无时无刻不在因风借力。数学与玄学暂且被我们把握为一个薄脊的符号客体，一定程度上是因为我们尚缺乏体验与阅历去支撑自己的认知。而这种偏见的傲慢更远在知性的傲慢之上。\r\n\r\n在孜孜矻矻以求操作系统意义的道路上，对自己的期望本就是在与数学与玄学对接中塑型的动态过程。而我们的底料便是对不同体系架构、不同终端的觉感与体认。IBM为比尔盖茨送去磁盘，又维系操作系统。他的操作系统观念是厚实的，也是实践的。倘若我们在对过往借乔布斯之言“祓魅”后，又对不断膨胀的自我进行“赋魅”，那么在丢失外界预期的同时，未尝也不是丢了自我。\r\n\r\n毫无疑问，从玄学与数学角度一觇的自我有偏狭过时的成分。但我们所应摒弃的不是对此的批判，而是其批判的廉价，其对批判投诚中的反智倾向。在linus的观念中，如果在成为狮子与孩子之前，略去了像骆驼一样背负前人遗产的过程，那其“永远重复”洵不能成立。\r\n\r\n蓝图上的落差终归只是理念上的区分，在实践场域的分野也未必明晰。譬如当我们追寻更好的桌面环境时，在途中涉足内存，这究竟是伴随着期望的泯灭还是期望的达成？在我们塑造liunx操作系统的同时，linux操作系统也在浇铸我们。既不可否认原生的开放性与多用户性，又承认自己的图景有轻狂的失真，不妨让体验走在言语之前。用不被禁锢的头脑去体味linus的大海与风帆，并效泡利，对无法言说之事保持沉默。\r\n\r\n用在linux上的生活方式体现个体的超越性，保持婞直却又不拘泥于所谓“遗世独立”的单向度形象。这便是linus为我们提供的理想期望范式。生活在linux上——始终热爱大地——升上天空。","author":"qianxi0410"},{"id":3,"title":"Two Sum ","created_at":"2022-04-19T06:56:16Z","updated_at":"2022-07-19T05:14:07Z","content":"### Two Sum\r\n\r\n如果你没听过这个题，那么你一定是一个不合格的程序员。 ~~断言丁真，鉴定为真~~\r\n\r\n作为 `L站` 的第一题，相信大部分人是听过/写过的，即便你第一遍没写出来 ~~我就没写出来~~，看了官方的解答之后也能够很快明白其原理。\r\n\r\n官方解答中的两种做法，一个是时间换空间，即开个双循环遍历，另外一种则是空间换时间，即开个map记录。\r\n\r\n这两种思路都比较 naive，但是如果要用 `TypeScript` 中的类型体操来完成测试又该如何呢？\r\n\r\n首先，开个map记录下标这种做法，我尝试过很久（指几十分钟），被我认定为不可行。 ~~也可能是我太菜了~~\r\n\r\n那么就决定是你了！循环遍历！\r\n\r\n首先，需要定义好需要完成的类型：\r\n\r\n```typescript\r\ntype TwoSum<Arr extends number[], target extends number> = any;\r\n```\r\n\r\n和 `L站` 上的定义相仿，接受一个数组（元组）和一个目标值参数，并且返回一个元组。当然，在泛型当中，参数自然也是泛型参数。\r\n\r\n不借助 **外力** 的话，显然这个类型无法达到所需要的体操效果。你必须考虑的是，如何循环遍历这第一个参数呢？\r\n\r\n> 需要注意的是，在ts中，循环是通过递归调用来实现的，因为类型是不可变的，自然需要比较函数式的做法，即递归。\r\n\r\n为了不破坏调用的方式，你可以定义一个辅助类型，但是我这里选择的是默认参数类型，即：\r\n\r\n```typescript\r\ntype TwoSum<\r\n  Arr extends number[],\r\n  target extends number,\r\n  I extends number = 0,\r\n  J extends number = Add<I, 1>,\r\n  ArrLen extends number = Length<Arr>,\r\n> = any;\r\n```\r\n\r\n和常规的做法类似，双循环，自然是需要两个变量： `i, j`，还有一个变量是用来记录传入元组的长度，当然，它是可选的。\r\n\r\n注意到，`i,j`的初始值分别是0和 `Add<I, 1>` ，即0和1，这类似于 `for ` 循环中的双重循环的初始化方式。\r\n\r\n在进行下一步之前，需要将辅助类型 `Add` 和 `Length` 进行实现。\r\n\r\n首先是 `Length`，需要知道的是，数组/元组有一个叫做 `length` 的属性，上面直接记录了该数组/元组的长度，所以 `Length` 的实现直接返回该属性值即可：\r\n\r\n```typescript\r\ntype Length<T extends unknown[]> = T['length'];\r\n```\r\n\r\n其次是 `Add`，实现 `Add` 有很复杂的做法，但是这里只需要理解其思路，就实现一个比较 naive 的 `Add` 即可，思路是：造 `A、B` 两个长度的元组，并且返回两个元组合并后的长度，即 `A + B` 的值。\r\n\r\n```typescript\r\ntype Push<T extends unknown[], Val> = [...T, Val];\r\n\r\ntype NTuple<N extends number, T extends unknown[] = []> = T['length'] extends N\r\n  ? T\r\n  : NTuple<N, Push<T, unknown>>;\r\n\r\ntype Add<A extends number, B extends number> = Length<\r\n  [...NTuple<A>, ...NTuple<B>]\r\n>;\r\n```\r\n\r\n当然，在写的过程中，你还需要一个辅助类型，用来提取出 `number` 类型：\r\n\r\n```typescript\r\ntype Num<T> = Extract<T, number>;\r\n```\r\n\r\n上述的辅助工作做完之后，可以开始写真正的逻辑：\r\n\r\n```typescript\r\ntype TwoSum<\r\n  Arr extends number[],\r\n  target extends number,\r\n  I extends number = 0,\r\n  J extends number = Num<Add<I, 1>>,\r\n  ArrLen extends number = Length<Arr>,\r\n> = I extends ArrLen\r\n  ? []\r\n  : J extends ArrLen\r\n  ? TwoSum<Arr, target, Num<Add<I, 1>>>\r\n  : Add<Arr[I], Arr[J]> extends target\r\n  ? [I, J]\r\n  : TwoSum<Arr, target, I, Num<Add<J, 1>>>;\r\n```\r\n\r\n令人恶心的三元表达式，不过分析起来也不算复杂：\r\n\r\n1. 判断 `I` 是否已经到达末尾，是则返回空元组，没有则2.\r\n2. 判断 `J`是否到达末尾，是则开始 `I + 1`次外循环，没有则3.\r\n3. 既然 `I,J` 都合法，则判断 `Arr[I] + Arr[J]` 是否为目标值，是则返回对应下标，没有则4.\r\n4. `I` 不变，`J`加1，继续循环。\r\n\r\n\r\n\r\n以上，就是类型体操做 `Two Sum` 的全部逻辑，写几个简单的 case 测试一下：\r\n\r\n```typescript\r\nExpect<Equal<TwoSum<[2, 7, 11, 5], 9>, [0, 1]>>\r\nExpect<Equal<TwoSum<[3, 2, 4], 6>, [1, 2]>>\r\nExpect<Equal<TwoSum<[3, 3], 6>, [0, 1]>>\r\nExpect<Equal<TwoSum<[2, 7, 11, 5], 10>, []>>\r\nExpect<Equal<TwoSum<[1, 3, 6, 7, 9], 10>, [0, 4]>>\r\n```\r\n\r\nWork. :D","author":"qianxi0410"}]},"__N_SSG":true}