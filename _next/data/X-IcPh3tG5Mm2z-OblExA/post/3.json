{"pageProps":{"post":{"id":3,"title":"Two Sum ","created_at":"2022-04-19T06:56:16Z","updated_at":"2022-07-19T05:14:07Z","content":"### Two Sum\r\n\r\n如果你没听过这个题，那么你一定是一个不合格的程序员。 ~~断言丁真，鉴定为真~~\r\n\r\n作为 `L站` 的第一题，相信大部分人是听过/写过的，即便你第一遍没写出来 ~~我就没写出来~~，看了官方的解答之后也能够很快明白其原理。\r\n\r\n官方解答中的两种做法，一个是时间换空间，即开个双循环遍历，另外一种则是空间换时间，即开个map记录。\r\n\r\n这两种思路都比较 naive，但是如果要用 `TypeScript` 中的类型体操来完成测试又该如何呢？\r\n\r\n首先，开个map记录下标这种做法，我尝试过很久（指几十分钟），被我认定为不可行。 ~~也可能是我太菜了~~\r\n\r\n那么就决定是你了！循环遍历！\r\n\r\n首先，需要定义好需要完成的类型：\r\n\r\n```typescript\r\ntype TwoSum<Arr extends number[], target extends number> = any;\r\n```\r\n\r\n和 `L站` 上的定义相仿，接受一个数组（元组）和一个目标值参数，并且返回一个元组。当然，在泛型当中，参数自然也是泛型参数。\r\n\r\n不借助 **外力** 的话，显然这个类型无法达到所需要的体操效果。你必须考虑的是，如何循环遍历这第一个参数呢？\r\n\r\n> 需要注意的是，在ts中，循环是通过递归调用来实现的，因为类型是不可变的，自然需要比较函数式的做法，即递归。\r\n\r\n为了不破坏调用的方式，你可以定义一个辅助类型，但是我这里选择的是默认参数类型，即：\r\n\r\n```typescript\r\ntype TwoSum<\r\n  Arr extends number[],\r\n  target extends number,\r\n  I extends number = 0,\r\n  J extends number = Add<I, 1>,\r\n  ArrLen extends number = Length<Arr>,\r\n> = any;\r\n```\r\n\r\n和常规的做法类似，双循环，自然是需要两个变量： `i, j`，还有一个变量是用来记录传入元组的长度，当然，它是可选的。\r\n\r\n注意到，`i,j`的初始值分别是0和 `Add<I, 1>` ，即0和1，这类似于 `for ` 循环中的双重循环的初始化方式。\r\n\r\n在进行下一步之前，需要将辅助类型 `Add` 和 `Length` 进行实现。\r\n\r\n首先是 `Length`，需要知道的是，数组/元组有一个叫做 `length` 的属性，上面直接记录了该数组/元组的长度，所以 `Length` 的实现直接返回该属性值即可：\r\n\r\n```typescript\r\ntype Length<T extends unknown[]> = T['length'];\r\n```\r\n\r\n其次是 `Add`，实现 `Add` 有很复杂的做法，但是这里只需要理解其思路，就实现一个比较 naive 的 `Add` 即可，思路是：造 `A、B` 两个长度的元组，并且返回两个元组合并后的长度，即 `A + B` 的值。\r\n\r\n```typescript\r\ntype Push<T extends unknown[], Val> = [...T, Val];\r\n\r\ntype NTuple<N extends number, T extends unknown[] = []> = T['length'] extends N\r\n  ? T\r\n  : NTuple<N, Push<T, unknown>>;\r\n\r\ntype Add<A extends number, B extends number> = Length<\r\n  [...NTuple<A>, ...NTuple<B>]\r\n>;\r\n```\r\n\r\n当然，在写的过程中，你还需要一个辅助类型，用来提取出 `number` 类型：\r\n\r\n```typescript\r\ntype Num<T> = Extract<T, number>;\r\n```\r\n\r\n上述的辅助工作做完之后，可以开始写真正的逻辑：\r\n\r\n```typescript\r\ntype TwoSum<\r\n  Arr extends number[],\r\n  target extends number,\r\n  I extends number = 0,\r\n  J extends number = Num<Add<I, 1>>,\r\n  ArrLen extends number = Length<Arr>,\r\n> = I extends ArrLen\r\n  ? []\r\n  : J extends ArrLen\r\n  ? TwoSum<Arr, target, Num<Add<I, 1>>>\r\n  : Add<Arr[I], Arr[J]> extends target\r\n  ? [I, J]\r\n  : TwoSum<Arr, target, I, Num<Add<J, 1>>>;\r\n```\r\n\r\n令人恶心的三元表达式，不过分析起来也不算复杂：\r\n\r\n1. 判断 `I` 是否已经到达末尾，是则返回空元组，没有则2.\r\n2. 判断 `J`是否到达末尾，是则开始 `I + 1`次外循环，没有则3.\r\n3. 既然 `I,J` 都合法，则判断 `Arr[I] + Arr[J]` 是否为目标值，是则返回对应下标，没有则4.\r\n4. `I` 不变，`J`加1，继续循环。\r\n\r\n\r\n\r\n以上，就是类型体操做 `Two Sum` 的全部逻辑，写几个简单的 case 测试一下：\r\n\r\n```typescript\r\nExpect<Equal<TwoSum<[2, 7, 11, 5], 9>, [0, 1]>>\r\nExpect<Equal<TwoSum<[3, 2, 4], 6>, [1, 2]>>\r\nExpect<Equal<TwoSum<[3, 3], 6>, [0, 1]>>\r\nExpect<Equal<TwoSum<[2, 7, 11, 5], 10>, []>>\r\nExpect<Equal<TwoSum<[1, 3, 6, 7, 9], 10>, [0, 4]>>\r\n```\r\n\r\nWork. :D","author":"qianxi0410"}},"__N_SSG":true}