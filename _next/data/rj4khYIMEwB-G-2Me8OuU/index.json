{"pageProps":{"user":{"login":"qianxi0410","nick_name":"q1anx1","avatar_url":"https://avatars.githubusercontent.com/u/55543743?v=4","bio":"gopher at day, rustacean at night."},"posts":[{"id":4,"title":"生活在linux上","created_at":"2022-05-03T06:27:37Z","updated_at":"2022-07-19T05:13:57Z","content":"现代操作系统以华为的 \"鸿蒙HarmonyOS 系统是面向万物互联的全场景分布式操作系统\" 为嚆矢。滥觞于玄学与数学的期望正失去它们的借鉴意义。但面对看似无垠的未来天空，我想循linus \"A computer is like air conditioning – it becomes useless when you open  Windows.\" 好过过早地振翮。\r\n\r\n我们怀揣热忱的灵魂天然被赋予对超越性的追求，不屑于古旧坐标的约束，钟情于在别处的芬芳。但当这种期望流于对Windows主义不假思索的批判，乃至走向原教旨与开源主义时，便值得警惕了。与秩序的落差、错位向来不能为越矩的行为张本。而纵然我们已有翔实的蓝图，仍不能自持已在浪潮之巅立下了自己的沉锚。\r\n\r\n\"wsl is a better way to use linux.\" M$之言可谓切中了肯綮。人的好奇心是不可祓除的，而我们欲上青云也无时无刻不在因风借力。数学与玄学暂且被我们把握为一个薄脊的符号客体，一定程度上是因为我们尚缺乏体验与阅历去支撑自己的认知。而这种偏见的傲慢更远在知性的傲慢之上。\r\n\r\n在孜孜矻矻以求操作系统意义的道路上，对自己的期望本就是在与数学与玄学对接中塑型的动态过程。而我们的底料便是对不同体系架构、不同终端的觉感与体认。IBM为比尔盖茨送去磁盘，又维系操作系统。他的操作系统观念是厚实的，也是实践的。倘若我们在对过往借乔布斯之言“祓魅”后，又对不断膨胀的自我进行“赋魅”，那么在丢失外界预期的同时，未尝也不是丢了自我。\r\n\r\n毫无疑问，从玄学与数学角度一觇的自我有偏狭过时的成分。但我们所应摒弃的不是对此的批判，而是其批判的廉价，其对批判投诚中的反智倾向。在linus的观念中，如果在成为狮子与孩子之前，略去了像骆驼一样背负前人遗产的过程，那其“永远重复”洵不能成立。\r\n\r\n蓝图上的落差终归只是理念上的区分，在实践场域的分野也未必明晰。譬如当我们追寻更好的桌面环境时，在途中涉足内存，这究竟是伴随着期望的泯灭还是期望的达成？在我们塑造liunx操作系统的同时，linux操作系统也在浇铸我们。既不可否认原生的开放性与多用户性，又承认自己的图景有轻狂的失真，不妨让体验走在言语之前。用不被禁锢的头脑去体味linus的大海与风帆，并效泡利，对无法言说之事保持沉默。\r\n\r\n用在linux上的生活方式体现个体的超越性，保持婞直却又不拘泥于所谓“遗世独立”的单向度形象。这便是linus为我们提供的理想期望范式。生活在linux上——始终热爱大地——升上天空。","author":"qianxi0410"},{"id":3,"title":"Two Sum ","created_at":"2022-04-19T06:56:16Z","updated_at":"2022-07-19T05:14:07Z","content":"### Two Sum\r\n\r\n如果你没听过这个题，那么你一定是一个不合格的程序员。 ~~断言丁真，鉴定为真~~\r\n\r\n作为 `L站` 的第一题，相信大部分人是听过/写过的，即便你第一遍没写出来 ~~我就没写出来~~，看了官方的解答之后也能够很快明白其原理。\r\n\r\n官方解答中的两种做法，一个是时间换空间，即开个双循环遍历，另外一种则是空间换时间，即开个map记录。\r\n\r\n这两种思路都比较 naive，但是如果要用 `TypeScript` 中的类型体操来完成测试又该如何呢？\r\n\r\n首先，开个map记录下标这种做法，我尝试过很久（指几十分钟），被我认定为不可行。 ~~也可能是我太菜了~~\r\n\r\n那么就决定是你了！循环遍历！\r\n\r\n首先，需要定义好需要完成的类型：\r\n\r\n```typescript\r\ntype TwoSum<Arr extends number[], target extends number> = any;\r\n```\r\n\r\n和 `L站` 上的定义相仿，接受一个数组（元组）和一个目标值参数，并且返回一个元组。当然，在泛型当中，参数自然也是泛型参数。\r\n\r\n不借助 **外力** 的话，显然这个类型无法达到所需要的体操效果。你必须考虑的是，如何循环遍历这第一个参数呢？\r\n\r\n> 需要注意的是，在ts中，循环是通过递归调用来实现的，因为类型是不可变的，自然需要比较函数式的做法，即递归。\r\n\r\n为了不破坏调用的方式，你可以定义一个辅助类型，但是我这里选择的是默认参数类型，即：\r\n\r\n```typescript\r\ntype TwoSum<\r\n  Arr extends number[],\r\n  target extends number,\r\n  I extends number = 0,\r\n  J extends number = Add<I, 1>,\r\n  ArrLen extends number = Length<Arr>,\r\n> = any;\r\n```\r\n\r\n和常规的做法类似，双循环，自然是需要两个变量： `i, j`，还有一个变量是用来记录传入元组的长度，当然，它是可选的。\r\n\r\n注意到，`i,j`的初始值分别是0和 `Add<I, 1>` ，即0和1，这类似于 `for ` 循环中的双重循环的初始化方式。\r\n\r\n在进行下一步之前，需要将辅助类型 `Add` 和 `Length` 进行实现。\r\n\r\n首先是 `Length`，需要知道的是，数组/元组有一个叫做 `length` 的属性，上面直接记录了该数组/元组的长度，所以 `Length` 的实现直接返回该属性值即可：\r\n\r\n```typescript\r\ntype Length<T extends unknown[]> = T['length'];\r\n```\r\n\r\n其次是 `Add`，实现 `Add` 有很复杂的做法，但是这里只需要理解其思路，就实现一个比较 naive 的 `Add` 即可，思路是：造 `A、B` 两个长度的元组，并且返回两个元组合并后的长度，即 `A + B` 的值。\r\n\r\n```typescript\r\ntype Push<T extends unknown[], Val> = [...T, Val];\r\n\r\ntype NTuple<N extends number, T extends unknown[] = []> = T['length'] extends N\r\n  ? T\r\n  : NTuple<N, Push<T, unknown>>;\r\n\r\ntype Add<A extends number, B extends number> = Length<\r\n  [...NTuple<A>, ...NTuple<B>]\r\n>;\r\n```\r\n\r\n当然，在写的过程中，你还需要一个辅助类型，用来提取出 `number` 类型：\r\n\r\n```typescript\r\ntype Num<T> = Extract<T, number>;\r\n```\r\n\r\n上述的辅助工作做完之后，可以开始写真正的逻辑：\r\n\r\n```typescript\r\ntype TwoSum<\r\n  Arr extends number[],\r\n  target extends number,\r\n  I extends number = 0,\r\n  J extends number = Num<Add<I, 1>>,\r\n  ArrLen extends number = Length<Arr>,\r\n> = I extends ArrLen\r\n  ? []\r\n  : J extends ArrLen\r\n  ? TwoSum<Arr, target, Num<Add<I, 1>>>\r\n  : Add<Arr[I], Arr[J]> extends target\r\n  ? [I, J]\r\n  : TwoSum<Arr, target, I, Num<Add<J, 1>>>;\r\n```\r\n\r\n令人恶心的三元表达式，不过分析起来也不算复杂：\r\n\r\n1. 判断 `I` 是否已经到达末尾，是则返回空元组，没有则2.\r\n2. 判断 `J`是否到达末尾，是则开始 `I + 1`次外循环，没有则3.\r\n3. 既然 `I,J` 都合法，则判断 `Arr[I] + Arr[J]` 是否为目标值，是则返回对应下标，没有则4.\r\n4. `I` 不变，`J`加1，继续循环。\r\n\r\n\r\n\r\n以上，就是类型体操做 `Two Sum` 的全部逻辑，写几个简单的 case 测试一下：\r\n\r\n```typescript\r\nExpect<Equal<TwoSum<[2, 7, 11, 5], 9>, [0, 1]>>\r\nExpect<Equal<TwoSum<[3, 2, 4], 6>, [1, 2]>>\r\nExpect<Equal<TwoSum<[3, 3], 6>, [0, 1]>>\r\nExpect<Equal<TwoSum<[2, 7, 11, 5], 10>, []>>\r\nExpect<Equal<TwoSum<[1, 3, 6, 7, 9], 10>, [0, 4]>>\r\n```\r\n\r\nWork. :D","author":"qianxi0410"}]},"__N_SSG":true}