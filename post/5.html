<!DOCTYPE html><html lang="zh-CN" id="html"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>qianxi0410&#x27;s website</title><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/css/43c5b47e69519c7e.css" as="style"/><link rel="stylesheet" href="/_next/static/css/43c5b47e69519c7e.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-5752944655d749a0.js" defer=""></script><script src="/_next/static/chunks/framework-2ea954a4e58c9061.js" defer=""></script><script src="/_next/static/chunks/main-01ea321eb7b53a22.js" defer=""></script><script src="/_next/static/chunks/pages/_app-8669b34f0d914bcb.js" defer=""></script><script src="/_next/static/chunks/707-1d623f86d0e6cf29.js" defer=""></script><script src="/_next/static/chunks/251-1424cfd6758237ec.js" defer=""></script><script src="/_next/static/chunks/804-796474adc7b98d66.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bid%5D-982a6338104274a7.js" defer=""></script><script src="/_next/static/14qot4Fp_htuilINt0wwR/_buildManifest.js" defer=""></script><script src="/_next/static/14qot4Fp_htuilINt0wwR/_ssgManifest.js" defer=""></script></head><body class="dark:bg-black bg-gray-50"><div id="__next"><div class="w-full sm:w-10/12 md:w-9/12 lg:w-7/12 container"><script>!function(){try{var d=document.documentElement,n='data-theme',s='setAttribute';var e=localStorage.getItem('theme');if('system'===e||(!e&&true)){var t='(prefers-color-scheme: dark)',m=window.matchMedia(t);if(m.media!==t||m.matches){d.style.colorScheme = 'dark';d[s](n,'dark')}else{d.style.colorScheme = 'light';d[s](n,'light')}}else if(e){d[s](n,e|| '')}if(e==='light'||e==='dark')d.style.colorScheme=e}catch(e){}}()</script><div class="my-10 sm:my-20"><div class="flex flex-col items-start mb-10"><div class="text-2xl sm:text-4xl font-bold dark:text-gray-200">Go的依赖更新检查工具</div><div class="sm:text-lg text-sm dark:text-gray-400"><span>qianxi0410</span> / <span>2022年5月7日</span> / <span>2022年7月19日</span></div></div><div class="font-normal"><p node="[object Object]" class="sm:text-xl text-lg my-4 dark:text-gray-300"><code class="bg-green-100 dark:bg-black dark:text-green-400" node="[object Object]">go module</code>，这是一个 Go 官方经历了多年，终于打算 <strong node="[object Object]" class="font-bold dark:text-gray-100">放下身段</strong> 汲取前人的经验所设计出来的一个产物，其历史可以参阅 Go官方的 <a href="https://github.com/golang/go/wiki/Modules" node="[object Object]" class="text-blue-500 hover:text-blue-800 transition-colors">wiki</a>。<del node="[object Object]" class="text-red-500">所以说，后来的 Gopher 们，那些口口声声， 一代不如一代的人，应该看着你们； 像我一样，我看着你们，满怀羡慕。</del></p>
<p node="[object Object]" class="sm:text-xl text-lg my-4 dark:text-gray-300">由于 Go 的一些哲学：比如遵循 <a href="https://semver.org/lang/zh-CN/" node="[object Object]" class="text-blue-500 hover:text-blue-800 transition-colors">语义化版本控制</a>，并且相同路径所引入的包必须向后兼容。这就要求库作者在发布大版本变动时，需要更改自身库的引入路径。综上的一切，导致了 Go 的更新依赖工具在检查依赖时，并不能进行主要版本号的更新，但那又怎么样呢？ <strong node="[object Object]" class="font-bold dark:text-gray-100">我偏要勉强！</strong></p>
<p node="[object Object]" class="sm:text-xl text-lg my-4 dark:text-gray-300">于是乎，追求最新版本的我，打算写一个能够 <a href="https://github.com/qianxi0410/gcu" node="[object Object]" class="text-blue-500 hover:text-blue-800 transition-colors">更新 go.mod 依赖主版本的工具</a>。</p>
<p node="[object Object]" class="sm:text-xl text-lg my-4 dark:text-gray-300">在写它之前，需要读过 <a href="https://go.dev/ref/mod" node="[object Object]" class="text-blue-500 hover:text-blue-800 transition-colors">这篇文章</a>，里面讲述了 Go 依赖的引入规则和一些 Go 模块命令的用法，并且还介绍了 Go 自己的一个 <a href="https://proxy.golang.org/" node="[object Object]" class="text-blue-500 hover:text-blue-800 transition-colors">依赖检查数据库网站</a>，这个网站是后续获取新版本依赖的关键。</p>
<p node="[object Object]" class="sm:text-xl text-lg my-4 dark:text-gray-300">看完之后，你应该有了一个大致的思路：</p>
<p node="[object Object]" class="sm:text-xl text-lg my-4 dark:text-gray-300">首先，需要能够解析出 <code class="bg-green-100 dark:bg-black dark:text-green-400" node="[object Object]">go.mod</code> 文件中所出现的依赖，由于 Go 的最小版本依赖原则，只需要将其中的直接依赖提取出来即可。</p>
<p node="[object Object]" class="sm:text-xl text-lg my-4 dark:text-gray-300">其次，将提取出来的依赖到上文提到的数据库中进行查询，得到现在最新的版本，写入 <code class="bg-green-100 dark:bg-black dark:text-green-400" node="[object Object]">go.mod</code> 文件。</p>
<p node="[object Object]" class="sm:text-xl text-lg my-4 dark:text-gray-300">写入完之后，判断新依赖的主版本是否 <code class="bg-green-100 dark:bg-black dark:text-green-400" node="[object Object]"> &gt;= 1</code>，如果不是，则升级过程到此结束。否则，需要判断其是否带有 <code class="bg-green-100 dark:bg-black dark:text-green-400" node="[object Object]">+incompatible</code> 标签，如果带有该标签，则不用进行后续的文件重写步骤，如果没有，需要遍历当前工作目录，重写主版本更新之后的模块的引入路径。</p>
<p node="[object Object]" class="sm:text-xl text-lg my-4 dark:text-gray-300">以上，你就完成了一个能够升级主要版本依赖的工具的核心功能。</p>
<p node="[object Object]" class="sm:text-xl text-lg my-4 dark:text-gray-300">当然，这也是 <code class="bg-green-100 dark:bg-black dark:text-green-400" node="[object Object]">gcu</code> 的雏形，但它作为一个 cli 工具，能做的远不止如此：</p>
<ul depth="0" node="[object Object]" class="sm:text-xl text-lg pl-5 dark:text-gray-400">
<li index="0" node="[object Object]" class="sm:text-xl text-lg my-2 dark:text-gray-300">它有丰富的TUI</li>
<li index="1" node="[object Object]" class="sm:text-xl text-lg my-2 dark:text-gray-300">它能够提供可选的依赖更新</li>
<li index="2" node="[object Object]" class="sm:text-xl text-lg my-2 dark:text-gray-300">如果你比较保守，它也能够不进行主要版本的更新，只进行次要版本和补丁版本的更新</li>
<li index="3" node="[object Object]" class="sm:text-xl text-lg my-2 dark:text-gray-300">它进行了多线程加速 <del node="[object Object]" class="text-red-500">所以它很快</del></li>
<li index="4" node="[object Object]" class="sm:text-xl text-lg my-2 dark:text-gray-300">它能够更新 Go 语言写的二进制文件的版本</li>
</ul>
<p node="[object Object]" class="sm:text-xl text-lg my-4 dark:text-gray-300">目前，该工具还是在制中，因为 <del node="[object Object]" class="text-red-500">一米八的</del> 我仍然在让它变得更快！</p></div><a class="float-right mt-10 sm:text-2xl text-xl text-gray-500 hover:text-black hover:underline hover:underline-offset-4 transition-all dark:text-gray-400 dark:hover:text-gray-100" href="/">cd ..</a><div class="bottom-0 mt-20"><p class="text-gray-800 text-sm sm:text-lg dark:text-gray-500">Powered by <a href="https://github.com/qianxi0410/gossip" class="text-blue-500 hover:underline transition-all">Gossip</a></p></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"id":5,"title":"Go的依赖更新检查工具","created_at":"2022-05-07T10:25:20Z","updated_at":"2022-07-19T05:14:19Z","content":"`go module`，这是一个 Go 官方经历了多年，终于打算 **放下身段** 汲取前人的经验所设计出来的一个产物，其历史可以参阅 Go官方的 [wiki](https://github.com/golang/go/wiki/Modules)。~~所以说，后来的 Gopher 们，那些口口声声， 一代不如一代的人，应该看着你们； 像我一样，我看着你们，满怀羡慕。~~\r\n\r\n由于 Go 的一些哲学：比如遵循 [语义化版本控制](https://semver.org/lang/zh-CN/)，并且相同路径所引入的包必须向后兼容。这就要求库作者在发布大版本变动时，需要更改自身库的引入路径。综上的一切，导致了 Go 的更新依赖工具在检查依赖时，并不能进行主要版本号的更新，但那又怎么样呢？ **我偏要勉强！**\r\n\r\n于是乎，追求最新版本的我，打算写一个能够 [更新 go.mod 依赖主版本的工具](https://github.com/qianxi0410/gcu)。\r\n\r\n在写它之前，需要读过 [这篇文章](https://go.dev/ref/mod)，里面讲述了 Go 依赖的引入规则和一些 Go 模块命令的用法，并且还介绍了 Go 自己的一个 [依赖检查数据库网站](https://proxy.golang.org/)，这个网站是后续获取新版本依赖的关键。\r\n\r\n看完之后，你应该有了一个大致的思路：\r\n\r\n首先，需要能够解析出 `go.mod` 文件中所出现的依赖，由于 Go 的最小版本依赖原则，只需要将其中的直接依赖提取出来即可。\r\n\r\n其次，将提取出来的依赖到上文提到的数据库中进行查询，得到现在最新的版本，写入 `go.mod` 文件。\r\n\r\n写入完之后，判断新依赖的主版本是否 ` \u003e= 1`，如果不是，则升级过程到此结束。否则，需要判断其是否带有 `+incompatible` 标签，如果带有该标签，则不用进行后续的文件重写步骤，如果没有，需要遍历当前工作目录，重写主版本更新之后的模块的引入路径。\r\n\r\n以上，你就完成了一个能够升级主要版本依赖的工具的核心功能。\r\n\r\n当然，这也是 `gcu` 的雏形，但它作为一个 cli 工具，能做的远不止如此：\r\n\r\n- 它有丰富的TUI\r\n- 它能够提供可选的依赖更新\r\n- 如果你比较保守，它也能够不进行主要版本的更新，只进行次要版本和补丁版本的更新\r\n- 它进行了多线程加速 ~~所以它很快~~\r\n- 它能够更新 Go 语言写的二进制文件的版本\r\n\r\n目前，该工具还是在制中，因为 ~~一米八的~~ 我仍然在让它变得更快！","author":"qianxi0410"}},"__N_SSG":true},"page":"/post/[id]","query":{"id":"5"},"buildId":"14qot4Fp_htuilINt0wwR","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>